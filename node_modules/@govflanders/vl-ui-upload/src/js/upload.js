import Dropzone from 'dropzone';

const uploadClass = `js-${vl.ns}upload`,
  filesBasicUploadClass = `${vl.ns}upload--basic`,
  draggingClass = `${vl.ns}upload--dragging`,

  filesClass = `${vl.ns}upload__files`,
  filesContainerClass = `${vl.ns}upload__files__container`,
  fileInputContainerClass = `${vl.ns}upload__files__input__container`,
  filesClose = `${vl.ns}upload__files__close`,
  hasFilesClass = `${vl.ns}upload__files--has-files`,
  filesInputClass = `${vl.ns}upload__element__input`,
  filesLabelClass = `${vl.ns}upload__element__label`,
  filesLabelButtonContainerClass = `${vl.ns}upload__element__button__container`,
  filesSizeErrorClass = `${vl.ns}upload__file--error-size`,

  dataUpload = `data-${vl.ns}upload`,
  dataUploadUrl = `${dataUpload}-url`,
  dataDressed = `${dataUpload}-dressed`,
  dataMaxSize = `${dataUpload}-max-size`,
  dataMaxFiles = `${dataUpload}-max-files`,
  dataErrorMessage = `${dataUpload}-error-message-filesize`,
  dataErrorMessageMaxFiles = `${dataUpload}-error-message-maxfiles`,
  dataErrorMessageFiletype = `${dataUpload}-error-message-accepted-files`,
  dataInputName = `${dataUpload}-input-name`,
  dataFullBodyDrop = `${dataUpload}-full-body-drop`,
  dataAllowedTypes = `${dataUpload}-accepted-files`,
  dataDisallowedDuplicates = `${dataUpload}-disallow-duplicates`,
  dataAutoprocess = `${dataUpload}-autoprocess`;

const _getTemplate = (name = '') => {
  const templateEl = document.getElementById(name);
  const templateContent = document.importNode(templateEl.content, true);

  return templateContent;
};

const _replaceStringValue = (stack, needle, replacement) => {
  return stack.replace(needle, replacement);
};

const _createErrorMessages = (element, size, maxFiles) => {
  const errorMessageFilesize = element.getAttribute(dataErrorMessage);
  const errorMessageMaxfiles = element.getAttribute(dataErrorMessageMaxFiles);
  const errorMessageFiletype = element.getAttribute(dataErrorMessageFiletype);
  const sizeInMB = vl.util.bytesToSize(size, true, 1024000);

  let dictFileTooBig, dictInvalidFileType, dictMaxFilesExceeded, dictResponseError;

  if (vl.util.exists(errorMessageFilesize)) {
    dictFileTooBig = _replaceStringValue(errorMessageFilesize, ':maxFsz', sizeInMB);
  } else {
    dictFileTooBig = vl.i18n.t('upload.file_to_big', sizeInMB);
  }

  if (vl.util.exists(errorMessageMaxfiles)) {
    dictMaxFilesExceeded = _replaceStringValue(errorMessageMaxfiles, ':maxfl', maxFiles);
  } else {
    dictMaxFilesExceeded = vl.i18n.t('upload.to_many_files', maxFiles);
  }

  if (vl.util.exists(errorMessageFiletype)) {
    const fileType = element.getAttribute('accept');

    dictInvalidFileType = _replaceStringValue(errorMessageFiletype, ':filetype', fileType)
  } else {
    dictInvalidFileType = vl.util.exists(errorMessageFiletype) ? errorMessageFiletype : vl.i18n.t('upload.file-type_not_allowed');
  }

  const messages = {
    dictFileTooBig,
    dictInvalidFileType,
    dictMaxFilesExceeded,
    dictResponseError: vl.i18n.t('upload.response_error'),
  };

  return messages;
}

const _getTemplateString = (template) => {
  const div = document.createElement('div');

  let parsedTemplate = div.cloneNode(true);
  parsedTemplate.appendChild(template);

  return parsedTemplate.innerHTML;
};

const _buildConfig = (element, id) => {
  const uploadTemplate = _getTemplate('uploadTemplate');
  const previewTemplate = _getTemplate('previewTemplate');
  let url = null;

  const uploadButtonContainer = uploadTemplate.querySelector(`.${filesLabelButtonContainerClass}`);
  const uploadButtonSub = uploadTemplate.querySelector(`.${filesLabelClass} small`);

  uploadButtonContainer.innerHTML = vl.i18n.t('upload.add_files');
  uploadButtonSub.innerHTML = vl.i18n.t('upload.add_files_subtitle');

  const uploadTemplateString = _getTemplateString(uploadTemplate);
  const previewTemplateString = _getTemplateString(previewTemplate);

  const previewsContainer = `#${id} .${filesContainerClass}`;
  const hiddenInputContainer = `#${id} .${fileInputContainerClass}`;

  if (element.hasAttribute(dataUploadUrl)) {
    url = element.getAttribute(dataUploadUrl);
  } else if (element.closest('form')) {
    if (element.closest('form').hasAttribute('action')) {
      url = element.closest('form').getAttribute('action');
    }
  } else {
    console.warn('No valid url given');
  }

  const autoProcessQueue = element.hasAttribute(dataAutoprocess) && element.getAttribute(dataAutoprocess) !== 'false';
  const size = element.hasAttribute(dataMaxSize) ? element.getAttribute(dataMaxSize) : 2000000;
  const acceptedFiles = element.hasAttribute(dataAllowedTypes) ? element.getAttribute(dataAllowedTypes) : null;

  const maxFilesize = vl.util.bytesToSize(size, false, 1000);
  const maxFiles = element.hasAttribute(dataMaxFiles) ? element.getAttribute(dataMaxFiles) : 1;

  const errorMessages = _createErrorMessages(element, size, maxFiles);
  const paramName = element.hasAttribute(dataInputName) ? element.hasAttribute(dataInputName) : 'file'

  const config = {
    autoProcessQueue,
    dictDefaultMessage: uploadTemplateString,
    maxFiles,
    maxFilesize,
    previewTemplate: previewTemplateString,
    previewsContainer,
    hiddenInputContainer,
    acceptedFiles,
    paramName,
    url,
    createImageThumbnails: false,
  };


  return Object.assign(config, errorMessages);

};
class Upload {
  constructor() {
    this.dropzoneInstances = [];
  }

  removeDuplicate(dz, file) {
    const files = dz.files;

    if (files) {
      let i = 0;
      let filesLength = files.length;
      let ref = files.slice();

      for (; i < filesLength - 1; i++) {
        if (ref[i] && file) {
          if (ref[i].name === file.name && ref[i].size === file.size) {
            dz.removeFile(ref[i]);
          }
        }
      }
    }
  }

  updateFileList(dz, el, file) {
    const fileList = el.querySelector(`.${filesClass}`);

    if (dz.files.length) {
      vl.util.addClass(fileList, hasFilesClass);

      if (el.hasAttribute(dataDisallowedDuplicates) && el.getAttribute(dataDisallowedDuplicates) === 'true') {
        this.removeDuplicate(dz, file);
      }
    } else {
      vl.util.removeClass(fileList, hasFilesClass);
    }
  }

  dress(element) {
    const self = this;

    if (vl.util.hasClass(element, filesBasicUploadClass)) {
      element.addEventListener('dragover', () => {
        vl.util.addClass(element, draggingClass);
      });

      element.addEventListener('dragleave', () => {
        vl.util.removeClass(element, draggingClass);
      });

      element.addEventListener('drop', () => {
        vl.util.removeClass(element, draggingClass);
      });
    } else {
      let id = null;

      vl.util.addClass(element, 'dropzone');

      // Add id if no id exists, else use existing id
      if (element.id) {
        id = element.id;
      } else {
        id = vl.util.uniqueId();

        element.id = id;
      }

      const config = _buildConfig(element, id);
      const filesWrapper = _getTemplate('previewFilesWrapper');
      const filesOverlay = _getTemplate('uploadOverlay');

      element.insertBefore(filesWrapper, element.firstChild);
      element.insertBefore(filesOverlay, element.firstChild);

      if (element.hasAttribute(dataFullBodyDrop)) {
        vl.util.addClass(element, 'vl-upload--full-body');

        document.body.addEventListener('dragover', (event) => {
          event.stopPropagation();
          vl.util.addClass(document.body, draggingClass);
        });

        element.addEventListener('dragover', (event) => {
          event.stopPropagation();
          vl.util.addClass(document.body, draggingClass);
        });

        element.addEventListener('dragleave', (event) => {
          event.stopPropagation();
          vl.util.removeClass(document.body, draggingClass);
        });

        element.addEventListener('drop', (event) => {
          event.stopPropagation();
          vl.util.removeClass(document.body, draggingClass);
        });
      }

      const dropzone = new Dropzone(element, config);

      this.dropzoneInstances.push(dropzone);

      vl.util.addClass(dropzone.hiddenFileInput, filesInputClass);

      dropzone.on('addedfile', (file) => {
        this.updateFileList(dropzone, element, file);
      });

      dropzone.on('addedfiles', () => {
        vl.util.triggerEvent(document, 'vl.upload.hook.fileChange');
      });

      dropzone.on('removedfile', () => {
        this.updateFileList(dropzone, element);
      });

      dropzone.on('error', (file, errorMessage) => {
        if (errorMessage === config.dictFileTooBig) {
          vl.util.addClass(file.previewTemplate, filesSizeErrorClass);
        }
      });

      // Add button functionality to remove all files
      if (vl.util.exists(element.querySelector(`.${filesClose}`))) {
        element.querySelector(`.${filesClose}`).addEventListener('click', (event) => {
          dropzone.removeAllFiles();

          this.updateFileList(dropzone, element);

          event.preventDefault();
        });
      }
    }
  }

  dressAll() {
    const elements = document.querySelectorAll(
      `.${uploadClass}:not([${dataDressed}]):not([data-${vl.ns}js-dress="false"]),
      [${dataUpload}]:not([${dataDressed}]):not([data-${vl.ns}js-dress="false"])`
    );

    vl.util.each(elements, (element) => {
      this.dress(element);
    });
  }

  undress(instance) {
    instance.destroy();
    this.updateFileList(instance, instance.element);

    this.dropzoneInstances = this.dropzoneInstances.filter(el => el !== instance);
  }

  undressAll() {
    vl.util.each(this.dropzoneInstances, instance => this.undress(instance));
  }
}

if(!('upload' in vl)) {
  document.addEventListener('DOMContentLoaded', () => {
    vl.upload = new Upload();
    vl.upload.dressAll();
  });
}

export default Upload;
